<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltrafastSecp256k1: UltrafastSecp256k1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltrafastSecp256k1<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Ultra high-performance secp256k1 elliptic curve cryptography library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">UltrafastSecp256k1 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> Ultra high-performance <a class="el" href="namespacesecp256k1.html">secp256k1</a> elliptic curve cryptography library with multi-platform support.</p>
<p><a href="https://github.com/shrec/UltrafastSecp256k1/stargazers"><img src="https://img.shields.io/github/stars/shrec/UltrafastSecp256k1?style=social" alt="GitHub stars" class="inline"/></a> <a href="https://github.com/shrec/UltrafastSecp256k1/network/members"><img src="https://img.shields.io/github/forks/shrec/UltrafastSecp256k1?style=social" alt="GitHub forks" class="inline"/></a></p>
<p><a href="https://github.com/shrec/UltrafastSecp256k1/actions/workflows/ci.yml"><img src="https://img.shields.io/github/actions/workflow/status/shrec/UltrafastSecp256k1/ci.yml?branch=main&amp;label=CI" alt="CI" class="inline"/></a> <a href="https://shrec.github.io/UltrafastSecp256k1/dev/bench/"><img src="https://img.shields.io/github/actions/workflow/status/shrec/UltrafastSecp256k1/benchmark.yml?branch=main&amp;label=Bench" alt="Benchmark" class="inline"/></a> <a href="https://github.com/shrec/UltrafastSecp256k1/releases/latest"><img src="https://img.shields.io/github/v/release/shrec/UltrafastSecp256k1?label=Release" alt="Release" class="inline"/></a> <a href="https://www.gnu.org/licenses/agpl-3.0"><img src="https://img.shields.io/badge/License-AGPL%20v3-blue.svg" alt="License: AGPL v3" style="pointer-events: none;" class="inline"/></a> <a href="https://en.cppreference.com/w/cpp/20"><img src="https://img.shields.io/badge/C%2B%2B-20-blue.svg" alt="C++20" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://developer.nvidia.com/cuda-toolkit"><img src="https://img.shields.io/badge/CUDA-12.0+-green.svg" alt="CUDA" style="pointer-events: none;" class="inline"/></a> <a href="https://www.khronos.org/opencl/"><img src="https://img.shields.io/badge/OpenCL-3.0-green.svg" alt="OpenCL" style="pointer-events: none;" class="inline"/></a> <a href="metal/"><img src="https://img.shields.io/badge/Apple%20Silicon-M1%2FM2%2FM3%2FM4-black.svg?logo=apple" alt="Apple Silicon" style="pointer-events: none;" class="inline"/></a> <a href="metal/"><img src="https://img.shields.io/badge/Metal-GPU%20Compute-silver.svg?logo=apple" alt="Metal" style="pointer-events: none;" class="inline"/></a> ![ROCm](https://img.shields.io/badge/ROCm-6.3%20HIP-red.svg) <a href="wasm/"><img src="https://img.shields.io/badge/WebAssembly-Emscripten-purple.svg" alt="WebAssembly" style="pointer-events: none;" class="inline"/></a> <a href="https://developer.android.com/ndk"><img src="https://img.shields.io/badge/ARM64-Cortex--A55%2FA76-orange.svg" alt="ARM64" style="pointer-events: none;" class="inline"/></a> <a href="https://riscv.org/"><img src="https://img.shields.io/badge/RISC--V-RV64GC-orange.svg" alt="RISC-V" style="pointer-events: none;" class="inline"/></a> <a href="android/"><img src="https://img.shields.io/badge/Android-NDK%20r27-brightgreen.svg" alt="Android" style="pointer-events: none;" class="inline"/></a> <a href="cmake/ios.toolchain.cmake"><img src="https://img.shields.io/badge/iOS-17%2B%20XCFramework-lightgrey.svg" alt="iOS" style="pointer-events: none;" class="inline"/></a> <a href="https://www.espressif.com/en/products/socs/esp32-s3"><img src="https://img.shields.io/badge/ESP32--S3-Xtensa%20LX7-orange.svg" alt="ESP32-S3" style="pointer-events: none;" class="inline"/></a> <a href="https://www.espressif.com/en/products/socs/esp32"><img src="https://img.shields.io/badge/ESP32-Xtensa%20LX6-orange.svg" alt="ESP32" style="pointer-events: none;" class="inline"/></a> <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32f103ze.html"><img src="https://img.shields.io/badge/STM32-Cortex--M3-orange.svg" alt="STM32" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
‚ö†Ô∏è Security Notice</h1>
<p><b>Research &amp; Development Project - Not Audited</b></p>
<p>This library has <b>not undergone independent security audits</b>. It is provided for research, educational, and experimental purposes.</p>
<p><b>Production Use:</b></p><ul>
<li>‚ùå Not recommended without independent cryptographic audit</li>
<li>‚ùå No formal security guarantees</li>
<li>‚úÖ All self-tests pass (76/76 including all backends)</li>
<li>‚úÖ Constant-time (CT) layer available for side-channel resistance</li>
</ul>
<p><b>Reporting Security Issues:</b></p><ul>
<li>Email: <a href="#" onclick="location.href='mai'+'lto:'+'pay'+'ys'+'oon'+'@g'+'mai'+'l.'+'com'; return false;">payysoon@gmail.com</a></li>
<li>GitHub Issues: <a href="https://github.com/shrec/UltrafastSecp256k1/issues">UltrafastSecp256k1/issues</a></li>
</ul>
<p><b>Disclaimer:</b> Users assume all risks. For production cryptographic systems, prefer audited libraries like <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md3"></a>
üöÄ Features</h1>
<ul>
<li><b>Multi-Platform Architecture</b><ul>
<li>CPU: Optimized for x86-64 (BMI2/ADX), RISC-V (RV64GC), and ARM64 (MUL/UMULH)</li>
<li>Mobile: Android ARM64 (NDK r27, Clang 18) + iOS 17+ (XCFramework, SPM, CocoaPods)</li>
<li>WebAssembly: Emscripten ES6 module with TypeScript declarations</li>
<li>Embedded: ESP32-S3 (Xtensa LX7) + ESP32-PICO-D4 (Xtensa LX6) + STM32F103 (ARM Cortex-M3)</li>
<li>GPU/CUDA: Batch operations with 4.63M kG/s throughput</li>
<li>GPU/Metal: Apple Silicon (M1/M2/M3/M4) with Comba-accelerated field arithmetic</li>
<li>GPU/ROCm (HIP): Portable PTX‚Üí__int128 fallbacks for AMD GPUs</li>
<li>GPU/OpenCL: PTX inline asm, 3.39M kG/s</li>
</ul>
</li>
<li><b>Performance</b><ul>
<li>x86-64: 3-5√ó speedup with BMI2/ADX assembly</li>
<li>ARM64: ~5√ó speedup with MUL/UMULH inline assembly</li>
<li>RISC-V: 2-3√ó speedup with native assembly</li>
<li>CUDA: Batch processing of thousands of operations in parallel</li>
</ul>
</li>
<li><b>Features</b><ul>
<li>Complete <a class="el" href="namespacesecp256k1.html">secp256k1</a> field and scalar arithmetic</li>
<li>Point addition, doubling, and multiplication</li>
<li>GLV endomorphism optimization</li>
<li>Efficient batch operations</li>
<li>ECDSA sign/verify (RFC 6979 deterministic nonce, low-S)</li>
<li>Schnorr BIP-340 sign/verify</li>
<li>SHA-256 hashing</li>
<li>Constant-time (CT) layer for side-channel resistance</li>
<li>Public key derivation</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Feature Coverage (v3.3.0)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category   </th><th class="markdownTableHeadNone">Component   </th><th class="markdownTableHeadNone">Status    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Core</b>   </td><td class="markdownTableBodyNone">Field, Scalar, Point, GLV, Precompute   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Assembly</b>   </td><td class="markdownTableBodyNone">x64 MASM/GAS, BMI2/ADX, RISC-V   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>SIMD</b>   </td><td class="markdownTableBodyNone">AVX2/AVX-512 batch ops, Montgomery batch inverse   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CT</b>   </td><td class="markdownTableBodyNone">Constant-time field/scalar/point   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>ECDSA</b>   </td><td class="markdownTableBodyNone">Sign/Verify, RFC 6979, DER/Compact, low-S   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Schnorr</b>   </td><td class="markdownTableBodyNone">BIP-340 sign/verify   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Recovery</b>   </td><td class="markdownTableBodyNone">ECDSA pubkey recovery (recid)   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>ECDH</b>   </td><td class="markdownTableBodyNone">Key exchange (raw, xonly, SHA-256)   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Multi-scalar</b>   </td><td class="markdownTableBodyNone">Strauss/Shamir   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Batch verify</b>   </td><td class="markdownTableBodyNone">ECDSA + Schnorr batch   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>BIP-32</b>   </td><td class="markdownTableBodyNone">HD derivation, path parsing, xprv/xpub   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>MuSig2</b>   </td><td class="markdownTableBodyNone">BIP-327, key aggregation, 2-round   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Taproot</b>   </td><td class="markdownTableBodyNone">BIP-341/342, tweak, Merkle   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Pedersen</b>   </td><td class="markdownTableBodyNone">Commitments, homomorphic, switch   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>FROST</b>   </td><td class="markdownTableBodyNone">Threshold signatures, t-of-n   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Adaptor</b>   </td><td class="markdownTableBodyNone">Schnorr + ECDSA adaptor sigs   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Address</b>   </td><td class="markdownTableBodyNone">P2PKH, P2WPKH, P2TR, Base58, Bech32/m   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Silent Pay</b>   </td><td class="markdownTableBodyNone">BIP-352   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Hashing</b>   </td><td class="markdownTableBodyNone">SHA-256, SHA-512, HMAC, Keccak-256   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Coins</b>   </td><td class="markdownTableBodyNone">27 coins, auto-dispatch, EIP-55   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Custom G</b>   </td><td class="markdownTableBodyNone">CurveContext, custom generator/curve   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>BIP-44</b>   </td><td class="markdownTableBodyNone">Coin-type HD, auto-purpose   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Self-test</b>   </td><td class="markdownTableBodyNone">Known vector verification   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GPU</b>   </td><td class="markdownTableBodyNone">CUDA, Metal, OpenCL, ROCm kernels   </td><td class="markdownTableBodyNone">‚úÖ    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Platforms</b>   </td><td class="markdownTableBodyNone">x64, ARM64, RISC-V, ESP32, WASM, iOS, Android, Metal, ROCm   </td><td class="markdownTableBodyNone">‚úÖ   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md5"></a>
ÔøΩ Batch Modular Inverse (Montgomery Trick)</h1>
<p>All backends include <b>batch modular inversion</b> ‚Äî a critical building block for Jacobian‚ÜíAffine conversion and high-throughput point operations:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Backend   </th><th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Function(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/field.cpp</code>   </td><td class="markdownTableBodyNone"><code>fe_batch_inverse(FieldElement*, size_t)</code> ‚Äî Montgomery trick with scratch buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/precompute.cpp</code>   </td><td class="markdownTableBodyNone"><code>batch_inverse(std::vector&lt;FieldElement&gt;&amp;)</code> ‚Äî vector variant    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>CUDA</b>   </td><td class="markdownTableBodyNone"><code>cuda/include/batch_inversion.cuh</code>   </td><td class="markdownTableBodyNone"><code>batch_inverse_montgomery</code> ‚Äî GPU Montgomery trick kernel    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CUDA</b>   </td><td class="markdownTableBodyNone"><code>cuda/include/batch_inversion.cuh</code>   </td><td class="markdownTableBodyNone"><code>batch_inverse_fermat</code> ‚Äî Fermat's little theorem variant    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>CUDA</b>   </td><td class="markdownTableBodyNone"><code>cuda/include/batch_inversion.cuh</code>   </td><td class="markdownTableBodyNone"><code>batch_inverse_kernel</code> ‚Äî production kernel (<code>__launch_bounds__(256, 4)</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CUDA</b>   </td><td class="markdownTableBodyNone"><code>cuda/src/test_suite.cu</code>   </td><td class="markdownTableBodyNone"><code>fe_batch_inverse()</code> ‚Äî host wrapper + unit tests    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Metal</b>   </td><td class="markdownTableBodyNone"><code>metal/shaders/secp256k1_kernels.metal</code>   </td><td class="markdownTableBodyNone"><code>batch_inverse</code> ‚Äî chunked Montgomery inverse (parallel threadgroups)   </td></tr>
</table>
<p><b>Algorithm</b>: Montgomery batch inverse computes N field inversions using only <b>1 modular inversion + 3(N‚àí1) multiplications</b>, amortizing the expensive inversion across the entire batch. </p>
<h1><a class="anchor" id="autotoc_md6"></a>
‚ö° Mixed Addition (Jacobian + Affine)</h1>
<p>The library provides <b>branchless mixed addition</b> (<code>add_mixed_inplace</code>) ‚Äî the fastest way to add a point with known affine coordinates (Z=1) to a Jacobian point. Uses the <b>madd-2007-bl</b> formula (7M + 4S, vs 11M + 5S for full Jacobian add).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Backend   </th><th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/point.cpp</code>   </td><td class="markdownTableBodyNone"><code>jacobian_add_mixed(JacobianPoint&amp;, AffinePoint&amp;)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/point.cpp</code>   </td><td class="markdownTableBodyNone"><code>Point::add_mixed_inplace(FieldElement&amp;, FieldElement&amp;)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/point.cpp</code>   </td><td class="markdownTableBodyNone"><code>Point::sub_mixed_inplace(FieldElement&amp;, FieldElement&amp;)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CPU</b>   </td><td class="markdownTableBodyNone"><code>cpu/src/precompute.cpp</code>   </td><td class="markdownTableBodyNone"><code>jacobian_add_mixed_local(JacobianPoint&amp;, AffinePointPacked&amp;)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>OpenCL</b>   </td><td class="markdownTableBodyNone"><code>opencl/kernels/secp256k1_point.cl</code>   </td><td class="markdownTableBodyNone"><code>point_add_mixed_impl(JacobianPoint*, AffinePoint*)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Metal</b>   </td><td class="markdownTableBodyNone"><code>metal/shaders/secp256k1_point.h</code>   </td><td class="markdownTableBodyNone"><code>jacobian_add_mixed(JacobianPoint&amp;, AffinePoint&amp;)</code>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md7"></a>
Usage Example (CPU)</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="point_8hpp.html">secp256k1/point.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start with generator point G</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> P = Point::generator();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get affine coordinates of G for mixed addition</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> gx = P.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#a9fac69f2a5fe229eb3bd933577eda9a4">x</a>();</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> gy = P.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#aa1c473d6c48e571884b379ca1859c23c">y</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute 2G using mixed add (Jacobian + Affine, 7M + 4S)</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> Q = Point::generator();</div>
<div class="line">Q.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#ab1c2e6e7b9d44952844ec3915dae9301">add_mixed_inplace</a>(gx, gy);  <span class="comment">// Q = G + G = 2G</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subtraction variant: Q = Q - G</span></div>
<div class="line">Q.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#a6eaf43dcf6153248964d52f67fe32c8f">sub_mixed_inplace</a>(gx, gy);  <span class="comment">// Q = 2G - G = G</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch walk: P, P+G, P+2G, ... using repeated mixed add</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> walker = P;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">    walker.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#ab1c2e6e7b9d44952844ec3915dae9301">add_mixed_inplace</a>(gx, gy);  <span class="comment">// walker += G each step</span></div>
<div class="line">    <span class="comment">// ... process walker ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1FieldElement_html"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1FieldElement.html">secp256k1::fast::FieldElement</a></div><div class="ttdef"><b>Definition</b> <a href="field_8hpp_source.html#l00042">field.hpp:42</a></div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html">secp256k1::fast::Point</a></div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00026">point.hpp:26</a></div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_a6eaf43dcf6153248964d52f67fe32c8f"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#a6eaf43dcf6153248964d52f67fe32c8f">secp256k1::fast::Point::sub_mixed_inplace</a></div><div class="ttdeci">void sub_mixed_inplace(const FieldElement &amp;ax, const FieldElement &amp;ay)</div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_a9fac69f2a5fe229eb3bd933577eda9a4"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#a9fac69f2a5fe229eb3bd933577eda9a4">secp256k1::fast::Point::x</a></div><div class="ttdeci">FieldElement x() const</div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_aa1c473d6c48e571884b379ca1859c23c"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#aa1c473d6c48e571884b379ca1859c23c">secp256k1::fast::Point::y</a></div><div class="ttdeci">FieldElement y() const</div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_ab1c2e6e7b9d44952844ec3915dae9301"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#ab1c2e6e7b9d44952844ec3915dae9301">secp256k1::fast::Point::add_mixed_inplace</a></div><div class="ttdeci">void add_mixed_inplace(const FieldElement &amp;ax, const FieldElement &amp;ay)</div></div>
<div class="ttc" id="anamespacesecp256k1_1_1fast_html"><div class="ttname"><a href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a></div><div class="ttdef"><b>Definition</b> <a href="batch__add__affine_8hpp_source.html#l00008">batch_add_affine.hpp:8</a></div></div>
<div class="ttc" id="apoint_8hpp_html"><div class="ttname"><a href="point_8hpp.html">point.hpp</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md8"></a>
Mixed Add + Batch Inverse: Collecting Z Values for Cheap Jacobian‚ÜíAffine</h2>
<p>During serial mixed additions, each point accumulates a growing Z coordinate. To extract affine X for comparison, you need Z‚Åª¬≤ ‚Äî which requires an expensive modular inversion. <b>Solution</b>: Collect Z values in a batch, then invert them all at once with Montgomery trick (1 inversion + 3N multiplications instead of N inversions).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="point_8hpp.html">secp256k1/point.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="field_8hpp.html">secp256k1/field.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> BATCH_SIZE = 1024;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Buffers (allocate once, reuse)</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> batch_points[BATCH_SIZE];</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> batch_z[BATCH_SIZE];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start from some point P</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> walker = Point::generator();</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> gx = walker.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#a9fac69f2a5fe229eb3bd933577eda9a4">x</a>();</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> gy = walker.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#aa1c473d6c48e571884b379ca1859c23c">y</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> idx = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (uint64_t j = 0; j &lt; total_count; ++j) {</div>
<div class="line">    <span class="comment">// Save point and its Z coordinate</span></div>
<div class="line">    batch_points[idx] = walker;</div>
<div class="line">    batch_z[idx] = walker.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#aa775c3b7871aa652fb9574c29db6c17d">z</a>();</div>
<div class="line">    idx++;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Advance walker using mixed add (7M + 4S)</span></div>
<div class="line">    walker.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#ab1c2e6e7b9d44952844ec3915dae9301">add_mixed_inplace</a>(gx, gy);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// When batch is full ‚Äî do batch inversion</span></div>
<div class="line">    <span class="keywordflow">if</span> (idx == BATCH_SIZE) {</div>
<div class="line">        <span class="comment">// ONE modular inversion for 1024 points!</span></div>
<div class="line">        fe_batch_inverse(batch_z.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a03e8e10d02591b02b4620037fe7bbe03">data</a>(), idx);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now batch_z[i] contains Z_i^(-1)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; idx; ++i) {</div>
<div class="line">            <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z_inv_sq = batch_z[i].<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a2a0ace299feb8784be069c602ba788ca">square</a>();         <span class="comment">// Z^(-2)</span></div>
<div class="line">            <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> x_affine = batch_points[i].<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#adb2783460ffc366169a78e7655da82ce">X</a>() * z_inv_sq;  <span class="comment">// X_affine = X_jac * Z^(-2)</span></div>
<div class="line">            <span class="comment">// Use x_affine as needed</span></div>
<div class="line">        }</div>
<div class="line">        idx = 0;  <span class="comment">// Reset batch</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1FieldElement_html_a03e8e10d02591b02b4620037fe7bbe03"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1FieldElement.html#a03e8e10d02591b02b4620037fe7bbe03">secp256k1::fast::FieldElement::data</a></div><div class="ttdeci">const ::secp256k1::FieldElementData &amp; data() const noexcept</div><div class="ttdef"><b>Definition</b> <a href="field_8hpp_source.html#l00085">field.hpp:85</a></div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1FieldElement_html_a2a0ace299feb8784be069c602ba788ca"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1FieldElement.html#a2a0ace299feb8784be069c602ba788ca">secp256k1::fast::FieldElement::square</a></div><div class="ttdeci">FieldElement square() const</div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_aa775c3b7871aa652fb9574c29db6c17d"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#aa775c3b7871aa652fb9574c29db6c17d">secp256k1::fast::Point::z</a></div><div class="ttdeci">const FieldElement &amp; z() const noexcept</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00051">point.hpp:51</a></div></div>
<div class="ttc" id="aclasssecp256k1_1_1fast_1_1Point_html_adb2783460ffc366169a78e7655da82ce"><div class="ttname"><a href="classsecp256k1_1_1fast_1_1Point.html#adb2783460ffc366169a78e7655da82ce">secp256k1::fast::Point::X</a></div><div class="ttdeci">const FieldElement &amp; X() const noexcept</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00049">point.hpp:49</a></div></div>
<div class="ttc" id="afield_8hpp_html"><div class="ttname"><a href="field_8hpp.html">field.hpp</a></div></div>
</div><!-- fragment --><p><b>Performance</b>: For N=1024 batch, this is **~500√ó cheaper** than individual inversions. A single field inversion costs ~3.5Œºs (Fermat), while batch amortizes to ~7ns per element.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
GPU Pattern: H-Product Serial Inversion (&lt;tt&gt;jacobian_add_mixed_h&lt;/tt&gt;)</h2>
<p>Production GPU apps use a more memory-efficient variant: instead of storing full Z coordinates, <code>jacobian_add_mixed_h</code> returns <b>H = U2 ‚àí X1</b> separately from each addition. Since Z_{k} = Z_0 ¬∑ H_0 ¬∑ H_1 ¬∑ ‚Ä¶ ¬∑ H_{k-1}, we can reconstruct and invert the entire Z chain from just the H values + initial Z_0.</p>
<p><b>Step 1 ‚Äî Collect H values during serial additions</b> (CUDA kernel): </p><div class="fragment"><div class="line">// jacobian_add_mixed_h: madd-2004-hmv (8M+3S), outputs H separately</div>
<div class="line">// H = U2 - X1, and internally computes Z3 = Z1 * H</div>
<div class="line">__device__ void jacobian_add_mixed_h(</div>
<div class="line">    const JacobianPoint* p, const AffinePoint* q,</div>
<div class="line">    JacobianPoint* r, FieldElement&amp; h_out);</div>
<div class="line"> </div>
<div class="line">// --- Step kernel: add G repeatedly, save X and H at each slot ---</div>
<div class="line">FieldElement h;</div>
<div class="line">win_z0[tid] = P.z;                    // Save initial Z_0</div>
<div class="line"> </div>
<div class="line">for (int slot = 0; slot &lt; batch_interval; ++slot) {</div>
<div class="line">    win_x[tid + slot * stride] = P.x; // Save Jacobian X</div>
<div class="line">    jacobian_add_mixed_h(&amp;P, &amp;G, &amp;P, h);</div>
<div class="line">    win_h[tid + slot * stride] = h;   // Save H (not Z!)</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Step 2 ‚Äî Serial Z chain inversion</b> (1 Fermat inversion per thread): </p><div class="fragment"><div class="line">// Forward: reconstruct Z_final = Z_0 * H_0 * H_1 * ... * H_{N-1}</div>
<div class="line">FieldElement z_current = z0_values[tid];</div>
<div class="line">for (int slot = 0; slot &lt; batch_interval; ++slot) {</div>
<div class="line">    z_current = z_current * h_array[tid + slot * stride];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ONE inversion of Z_final (Fermat: 255 sqr + 16 mul)</div>
<div class="line">FieldElement z_inv = field_inverse(z_current);</div>
<div class="line"> </div>
<div class="line">// Backward: unwind to get Z_slot^{-2} at each position</div>
<div class="line">for (int slot = batch_interval - 1; slot &gt;= 0; --slot) {</div>
<div class="line">    int idx = tid + slot * stride;</div>
<div class="line">    z_inv = z_inv * h_array[idx];     // Z_{slot}^{-1}</div>
<div class="line">    h_array[idx] = z_inv * z_inv;     // Z_{slot}^{-2} (overwrite H in-place!)</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Step 3 ‚Äî Affine X extraction</b>: </p><div class="fragment"><div class="line">// h_array now contains Z^{-2} at each slot</div>
<div class="line">for (int slot = 0; slot &lt; batch_interval; ++slot) {</div>
<div class="line">    int idx = tid + slot * stride;</div>
<div class="line">    FieldElement x_affine = win_x[idx] * h_array[idx];  // X_jac * Z^{-2}</div>
<div class="line">    // Use x_affine as needed</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Why H instead of Z?</b></p><ul>
<li><b>Memory</b>: H is a single field element; Z would also be a field element, but H is computed "for free" inside the addition ‚Äî no extra multiply needed</li>
<li><b>Serial inversion</b>: Z_k = Z_0 ¬∑ ‚àèH_i, so the backward sweep naturally yields Z_k^{-1} at each step using just the stored H values</li>
<li><b>In-place</b>: H array is overwritten with Z^{-2} ‚Äî zero extra memory allocation</li>
<li><b>Cost</b>: 1 Fermat inversion + 2N multiplications per thread (vs N Fermat inversions naively)</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;See production usage: <code>apps/secp256k1_search_gpu_only/gpu_only.cu</code> (step kernel) + <code>unified_split.cuh</code> (batch inversion kernel) </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md10"></a>
Other Batch Inverse Use Cases</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
1. Full Point Conversion: Jacobian ‚Üí Affine (X + Y)</h3>
<p>When you need both X and Y (precompute table, serialization, debugging):</p>
<div class="fragment"><div class="line"><span class="comment">// N Jacobian points ‚Üí N Affine points (1 inversion)</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z_values[N];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line">    z_values[i] = points[i].z();</div>
<div class="line"> </div>
<div class="line">fe_batch_inverse(z_values.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a03e8e10d02591b02b4620037fe7bbe03">data</a>(), N);  <span class="comment">// z_values[i] = Z_i^(-1)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">    <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z_inv = z_values[i];</div>
<div class="line">    <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z2 = z_inv.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a2a0ace299feb8784be069c602ba788ca">square</a>();          <span class="comment">// Z^(-2)</span></div>
<div class="line">    <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z3 = z2 * z_inv;              <span class="comment">// Z^(-3)</span></div>
<div class="line">    affine_x[i] = points[i].X() * z2;         <span class="comment">// X_affine = X_jac ¬∑ Z^(-2)</span></div>
<div class="line">    affine_y[i] = points[i].Y() * z3;         <span class="comment">// Y_affine = Y_jac ¬∑ Z^(-3)</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
2. X-Only Coordinate Extraction</h3>
<p>In most cases you don't need Y ‚Äî only the affine X coordinate is required:</p>
<div class="fragment"><div class="line"><span class="comment">// CPU pattern</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> BATCH_SIZE = 1024;</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1Point.html">Point</a> batch_points[BATCH_SIZE];</div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> batch_z[BATCH_SIZE];</div>
<div class="line"><span class="keywordtype">size_t</span> batch_idx = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (uint64_t j = start; j &lt; end; ++j) {</div>
<div class="line">    batch_points[batch_idx] = p;</div>
<div class="line">    batch_z[batch_idx] = p.z();</div>
<div class="line">    batch_idx++;</div>
<div class="line">    p.next_inplace();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (batch_idx == BATCH_SIZE || j == end - 1) {</div>
<div class="line">        fe_batch_inverse(batch_z.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a03e8e10d02591b02b4620037fe7bbe03">data</a>(), batch_idx);  <span class="comment">// 1 inversion!</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; batch_idx; ++i) {</div>
<div class="line">            <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> z_inv_sq = batch_z[i].<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a2a0ace299feb8784be069c602ba788ca">square</a>();           <span class="comment">// Z^(-2)</span></div>
<div class="line">            <a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> x_affine = batch_points[i].<a class="code hl_function" href="classsecp256k1_1_1fast_1_1Point.html#adb2783460ffc366169a78e7655da82ce">X</a>() * z_inv_sq;  <span class="comment">// X only!</span></div>
<div class="line">            <span class="comment">// Use x_affine as needed</span></div>
<div class="line">        }</div>
<div class="line">        batch_idx = 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
3. CUDA: Z Extraction ‚Üí batch_inverse_kernel ‚Üí Affine X</h3>
<p>On GPU where you have an array of <code>JacobianPoint</code> ‚Äî Z coordinates are extracted separately, inversion uses shared memory:</p>
<div class="fragment"><div class="line">// Step 1: Extract Z coordinates (1 kernel)</div>
<div class="line">__global__ void extract_z_kernel(const JacobianPoint* points,</div>
<div class="line">                                 FieldElement* zs, int n) {</div>
<div class="line">    int idx = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line">    if (idx &lt; n) zs[idx] = points[idx].z;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Step 2: Montgomery batch inverse (shared memory prefix/suffix scan)</div>
<div class="line">//         1 inversion per block, inner elements use multiplications only</div>
<div class="line">batch_inverse_kernel&lt;&lt;&lt;blocks, 256, shared_mem&gt;&gt;&gt;(d_zs, d_inv_zs, N);</div>
<div class="line"> </div>
<div class="line">// Step 3: Affine X = X_jac * Z_inv¬≤</div>
<div class="line">__global__ void affine_extraction_kernel(const JacobianPoint* points,</div>
<div class="line">                                         const FieldElement* inv_zs, ...) {</div>
<div class="line">    int idx = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line">    FieldElement z_inv = inv_zs[idx];</div>
<div class="line">    FieldElement z2;</div>
<div class="line">    field_sqr(&amp;z_inv, &amp;z2);           // Z^(-2)</div>
<div class="line">    FieldElement x_aff;</div>
<div class="line">    field_mul(&amp;points[idx].x, &amp;z2, &amp;x_aff);  // X_affine</div>
<div class="line">    // Use x_aff as needed</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
4. Batch Modular Division: a[i] / b[i]</h3>
<p>Arbitrary batch division for field elements:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> denominators[] = {b0, b1, b2, b3};</div>
<div class="line">fe_batch_inverse(denominators, 4);</div>
<div class="line"><span class="comment">// denominators[i] = b_i^(-1)</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> r0 = a0 * denominators[0];  <span class="comment">// a0 / b0</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> r1 = a1 * denominators[1];  <span class="comment">// a1 / b1</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> r2 = a2 * denominators[2];  <span class="comment">// a2 / b2</span></div>
<div class="line"><a class="code hl_class" href="classsecp256k1_1_1fast_1_1FieldElement.html">FieldElement</a> r3 = a3 * denominators[3];  <span class="comment">// a3 / b3</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
5. Scratch Buffer Reuse</h3>
<p>When processing multiple rounds, a single pre-allocated scratch buffer is reused across all rounds:</p>
<div class="fragment"><div class="line">std::vector&lt;FieldElement&gt; scratch;</div>
<div class="line">scratch.reserve(BATCH_SIZE);  <span class="comment">// Allocate once</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> round = 0; round &lt; total_rounds; ++round) {</div>
<div class="line">    <span class="comment">// ... fill batch_z[] ...</span></div>
<div class="line">    fe_batch_inverse(batch_z.<a class="code hl_function" href="classsecp256k1_1_1fast_1_1FieldElement.html#a03e8e10d02591b02b4620037fe7bbe03">data</a>(), N, scratch);  <span class="comment">// Reuses scratch buffer</span></div>
<div class="line">    <span class="comment">// ... affine conversion ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Montgomery Trick ‚Äî Full Algorithm Explanation</h2>
<div class="fragment"><div class="line">Input: [a‚ÇÄ, a‚ÇÅ, a‚ÇÇ, ..., a‚Çô‚Çã‚ÇÅ]</div>
<div class="line"> </div>
<div class="line">1) Forward pass ‚Äî cumulative products:</div>
<div class="line">   prod[0] = a‚ÇÄ</div>
<div class="line">   prod[1] = a‚ÇÄ ¬∑ a‚ÇÅ</div>
<div class="line">   prod[2] = a‚ÇÄ ¬∑ a‚ÇÅ ¬∑ a‚ÇÇ</div>
<div class="line">   ...</div>
<div class="line">   prod[N-1] = a‚ÇÄ ¬∑ a‚ÇÅ ¬∑ ... ¬∑ a‚Çô‚Çã‚ÇÅ</div>
<div class="line"> </div>
<div class="line">2) Single inversion:</div>
<div class="line">   inv = prod[N-1]‚Åª¬π = (a‚ÇÄ ¬∑ a‚ÇÅ ¬∑ ... ¬∑ a‚Çô‚Çã‚ÇÅ)‚Åª¬π</div>
<div class="line"> </div>
<div class="line">3) Backward pass ‚Äî extract individual inverses:</div>
<div class="line">   a‚Çô‚Çã‚ÇÅ‚Åª¬π = inv ¬∑ prod[N-2]</div>
<div class="line">   inv ‚Üê inv ¬∑ a‚Çô‚Çã‚ÇÅ(original)</div>
<div class="line">   a‚Çô‚Çã‚ÇÇ‚Åª¬π = inv ¬∑ prod[N-3]</div>
<div class="line">   inv ‚Üê inv ¬∑ a‚Çô‚Çã‚ÇÇ(original)</div>
<div class="line">   ...</div>
<div class="line">   a‚ÇÄ‚Åª¬π = inv</div>
<div class="line"> </div>
<div class="line">Cost: 1 inversion + 3(N-1) multiplications</div>
<div class="line">N=1024: 1√ó3.5Œºs + 3069√ó5ns ‚âà 18.8Œºs (vs 1024√ó3.5Œºs = 3584Œºs ‚Üí 190√ó faster!)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
ÔøΩüì¶ Use Cases</h1>
<blockquote class="doxtable">
<p>&zwj;### ‚ö†Ô∏è Testers Wanted We need community testers for platforms we cannot fully validate in CI:</p><ul>
<li><b>iOS</b> ‚Äî Build &amp; run on real iPhone/iPad hardware with Xcode</li>
<li><b>AMD GPU (ROCm/HIP)</b> ‚Äî Test on AMD Radeon RX / Instinct GPUs</li>
</ul>
<p>If you can help, please <a href="https://github.com/shrec/UltrafastSecp256k1/issues">open an issue</a> with your results! </p>
</blockquote>
<ul>
<li><b>Cryptocurrency Applications</b><ul>
<li>Bitcoin/Ethereum address generation</li>
<li>Transaction signing and verification</li>
<li>Hardware wallet integration</li>
<li>Bulk address validation</li>
</ul>
</li>
<li><b>Cryptographic Research</b><ul>
<li>ECC algorithm testing</li>
<li>Performance benchmarking</li>
<li>Custom curve implementations</li>
</ul>
</li>
<li><b>General Purpose</b><ul>
<li>Any application requiring <a class="el" href="namespacesecp256k1.html">secp256k1</a> operations</li>
<li>High-throughput cryptographic services</li>
<li>Embedded systems (RISC-V support)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
üîê Security Model</h1>
<p>UltrafastSecp256k1 is a performance-focused <a class="el" href="namespacesecp256k1.html">secp256k1</a> engine with two security profiles. See THREAT_MODEL.md for a full layer-by-layer risk assessment.</p>
<p>‚ö†Ô∏è <b>Constant-time behavior is NOT guaranteed unless you use the <code>ct::</code> namespace.</b></p>
<h2><a class="anchor" id="autotoc_md19"></a>
FAST Profile (Default)</h2>
<ul>
<li>Optimized for maximum throughput</li>
<li>Variable-time algorithms (timing side-channels possible)</li>
<li>Intended for:<ul>
<li>Public-key operations and verification</li>
<li>Batch processing and GPU workloads</li>
<li>Research and benchmarking</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
CT / HARDENED Profile (Implemented)</h2>
<ul>
<li>Constant-time arithmetic ‚Äî no secret-dependent branches or memory access</li>
<li>~5‚Äì7√ó performance penalty vs FAST</li>
<li>Provides: <code>ct::field_mul</code>, <code>ct::field_inv</code>, <code>ct::scalar_mul</code>, <code>ct::point_add_complete</code>, <code>ct::point_dbl</code></li>
<li>Use for: private key handling, signing, nonce operations</li>
</ul>
<p><b>Choose the appropriate profile for your use case.</b> Using FAST with secret data is a security vulnerability.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
üõ†Ô∏è Building</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Prerequisites</h2>
<ul>
<li>CMake 3.18+</li>
<li>C++20 compiler (GCC 11+, Clang/LLVM 15+)<ul>
<li>MSVC 2022+ (optional, disabled by default - use <code>-DSECP256K1_ALLOW_MSVC=ON</code>)</li>
</ul>
</li>
<li>CUDA Toolkit 12.0+ (optional, for GPU support)</li>
<li>Ninja (recommended)</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
CPU-Only Build</h2>
<div class="fragment"><div class="line">cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">cmake --build build -j</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
With CUDA Support</h2>
<div class="fragment"><div class="line">cmake -S . -B build -G Ninja \</div>
<div class="line">  -DCMAKE_BUILD_TYPE=Release \</div>
<div class="line">  -DSECP256K1_BUILD_CUDA=ON</div>
<div class="line">cmake --build build -j</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
WebAssembly (Emscripten)</h2>
<div class="fragment"><div class="line"># Requires Emscripten SDK (emsdk)</div>
<div class="line">./scripts/build_wasm.sh        # ‚Üí build-wasm/dist/</div>
</div><!-- fragment --><p>Output: <code>secp256k1_wasm.wasm</code> + <code>secp256k1.mjs</code> (ES6 module with TypeScript types). See wasm/README.md for JS/TS usage.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
iOS (XCFramework)</h2>
<div class="fragment"><div class="line">./scripts/build_xcframework.sh  # ‚Üí build-xcframework/output/</div>
</div><!-- fragment --><p>Produces a universal XCFramework (arm64 device + arm64 simulator). Also available via <b>Swift Package Manager</b> and <b>CocoaPods</b>.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Build Options</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SECP256K1_USE_ASM</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Enable assembly optimizations (x64/RISC-V)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SECP256K1_BUILD_CUDA</code>   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Build CUDA GPU support    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SECP256K1_BUILD_OPENCL</code>   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Build OpenCL GPU support    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SECP256K1_BUILD_ROCM</code>   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Build ROCm/HIP GPU support (AMD)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SECP256K1_BUILD_TESTS</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Build test suite    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SECP256K1_BUILD_BENCH</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Build benchmarks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SECP256K1_RISCV_FAST_REDUCTION</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Fast modular reduction (RISC-V)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SECP256K1_RISCV_USE_VECTOR</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">RVV vector extension (RISC-V)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md28"></a>
Build Profiles</h2>
<p>UltrafastSecp256k1 is designed with two conceptual build targets:</p>
<h3><a class="anchor" id="autotoc_md29"></a>
1Ô∏è‚É£ FAST (Performance Research Mode)</h3>
<ul>
<li>Maximum throughput</li>
<li>Aggressive compiler optimizations allowed</li>
<li>Suitable for:<ul>
<li>Benchmarking</li>
<li>Public key generation</li>
<li>Batch verification</li>
<li>High-performance research environments</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md30"></a>
2Ô∏è‚É£ CT (Constant-Time Hardened Mode)</h3>
<ul>
<li>Secret-dependent branches avoided</li>
<li>Deterministic execution paths</li>
<li>Safer for:<ul>
<li>Private key operations</li>
<li>Signing workflows</li>
<li>External-facing cryptographic services</li>
</ul>
</li>
</ul>
<p>CT mode is under continuous development and will be expanded with:</p>
<ul>
<li>Montgomery ladder options</li>
<li>Constant-time table selection</li>
<li>Optional blinding techniques</li>
<li>Timing regression testing integration</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
üéØ Quick Start</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Basic CPU Usage</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="field_8hpp.html">secp256k1/field.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="point_8hpp.html">secp256k1/point.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scalar_8hpp.html">secp256k1/scalar.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Field arithmetic</span></div>
<div class="line">    <span class="keyword">auto</span> a = FieldElement::from_hex(</div>
<div class="line">        <span class="stringliteral">&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141&quot;</span></div>
<div class="line">    );</div>
<div class="line">    <span class="keyword">auto</span> b = FieldElement::from_hex(</div>
<div class="line">        <span class="stringliteral">&quot;1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF&quot;</span></div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> sum = a + b;</div>
<div class="line">    <span class="keyword">auto</span> product = a * b;</div>
<div class="line">    <span class="keyword">auto</span> inverse = a.inverse();</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sum: &quot;</span> &lt;&lt; sum.to_hex() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Product: &quot;</span> &lt;&lt; product.to_hex() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 2. Point operations (public key derivation)</span></div>
<div class="line">    <span class="keyword">auto</span> generator = Point::generator();</div>
<div class="line">    <span class="keyword">auto</span> private_key = Scalar::from_hex(</div>
<div class="line">        <span class="stringliteral">&quot;E9873D79C6D87DC0FB6A5778633389F4453213303DA61F20BD67FC233AA33262&quot;</span></div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Multiply generator by private key</span></div>
<div class="line">    <span class="keyword">auto</span> public_key = generator * private_key;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Public Key X: &quot;</span> &lt;&lt; public_key.x().to_hex() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Public Key Y: &quot;</span> &lt;&lt; public_key.y().to_hex() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 3. Point addition</span></div>
<div class="line">    <span class="keyword">auto</span> point1 = Point::from_coordinates(</div>
<div class="line">        FieldElement::from_hex(<span class="stringliteral">&quot;...&quot;</span>),</div>
<div class="line">        FieldElement::from_hex(<span class="stringliteral">&quot;...&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">    <span class="keyword">auto</span> point2 = Point::from_coordinates(</div>
<div class="line">        FieldElement::from_hex(<span class="stringliteral">&quot;...&quot;</span>),</div>
<div class="line">        FieldElement::from_hex(<span class="stringliteral">&quot;...&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> result = point1 + point2;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ascalar_8hpp_html"><div class="ttname"><a href="scalar_8hpp.html">scalar.hpp</a></div></div>
</div><!-- fragment --><p><b>Compile &amp; Run:</b> </p><div class="fragment"><div class="line"># Link with the library</div>
<div class="line">g++ -std=c++20 example.cpp -lsecp256k1-fast-cpu -o example</div>
<div class="line">./example</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Advanced: Batch Signature Verification</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="point_8hpp.html">secp256k1/point.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scalar_8hpp.html">secp256k1/scalar.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> verify_signatures_batch(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; public_keys,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::array&lt;uint8_t, 32&gt;&gt;&amp; messages,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Scalar&gt;&amp; r_values,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Scalar&gt;&amp; s_values</div>
<div class="line">) {</div>
<div class="line">    <span class="keyword">auto</span> generator = Point::generator();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; public_keys.size(); ++i) {</div>
<div class="line">        <span class="comment">// Hash message</span></div>
<div class="line">        <span class="keyword">auto</span> msg_hash = Scalar::from_bytes(messages[i]);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Verify: s*G = R + hash*PubKey</span></div>
<div class="line">        <span class="keyword">auto</span> s_inv = s_values[i].inverse();</div>
<div class="line">        <span class="keyword">auto</span> u1 = msg_hash * s_inv;</div>
<div class="line">        <span class="keyword">auto</span> u2 = r_values[i] * s_inv;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> point = generator * u1 + public_keys[i] * u2;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (point.x().to_scalar() != r_values[i]) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
CUDA GPU Acceleration</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;secp256k1_cuda/batch_operations.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="point_8hpp.html">secp256k1/point.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Prepare batch data (1 million operations)</span></div>
<div class="line">    std::vector&lt;Point&gt; base_points(1&#39;000&#39;000);</div>
<div class="line">    std::vector&lt;Scalar&gt; scalars(1&#39;000&#39;000);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Fill with data...</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; base_points.size(); ++i) {</div>
<div class="line">        base_points[i] = Point::generator();</div>
<div class="line">        scalars[i] = Scalar::random();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// GPU batch multiplication</span></div>
<div class="line">    cuda::BatchConfig config{</div>
<div class="line">        .device_id = 0,</div>
<div class="line">        .threads_per_block = 256,</div>
<div class="line">        .streams = 4</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> results = cuda::batch_multiply(</div>
<div class="line">        base_points, </div>
<div class="line">        scalars, </div>
<div class="line">        config</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Processed &quot;</span> &lt;&lt; results.size() </div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; point multiplications on GPU\n&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Results are already on host memory</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; result : results) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result.x().to_hex() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Compile with CUDA:</b> </p><div class="fragment"><div class="line">nvcc -std=c++20 cuda_example.cpp \</div>
<div class="line">     -lsecp256k1-fast-cpu -lsecp256k1-fast-cuda \</div>
<div class="line">     -o cuda_example</div>
<div class="line">./cuda_example</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
CUDA: Batch Address Generation</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;secp256k1_cuda/batch_operations.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;secp256k1_cuda/address_generator.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Generate 10 million Bitcoin addresses on GPU</span></div>
<div class="line">    std::vector&lt;Scalar&gt; private_keys(10&#39;000&#39;000);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Fill with sequential or random keys</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; private_keys.size(); ++i) {</div>
<div class="line">        private_keys[i] = Scalar::from_int(i + 1);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// GPU batch generation</span></div>
<div class="line">    <span class="keyword">auto</span> addresses = cuda::generate_addresses(</div>
<div class="line">        private_keys,</div>
<div class="line">        cuda::AddressType::P2PKH <span class="comment">// Bitcoin P2PKH format</span></div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generated &quot;</span> &lt;&lt; addresses.size() &lt;&lt; <span class="stringliteral">&quot; addresses\n&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// First few addresses</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Address &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> </div>
<div class="line">                  &lt;&lt; addresses[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Performance Tuning Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="field_8hpp.html">secp256k1/field.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="field__asm_8hpp.html">secp256k1/field_asm.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> benchmark_field_multiply() {</div>
<div class="line">    <span class="keyword">auto</span> a = FieldElement::random();</div>
<div class="line">    <span class="keyword">auto</span> b = FieldElement::random();</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = 1&#39;000&#39;000;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Warm-up</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        <span class="keyword">volatile</span> <span class="keyword">auto</span> result = a * b;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">        <span class="keyword">volatile</span> <span class="keyword">auto</span> result = a * b;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(</div>
<div class="line">        end - start</div>
<div class="line">    ).count();</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Field multiply: &quot;</span> </div>
<div class="line">              &lt;&lt; (duration / iterations) &lt;&lt; <span class="stringliteral">&quot; ns/op\n&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check if using assembly</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacesecp256k1_1_1fast.html#a2bd3922bd58f8a6d328d28d52003c3a1">has_bmi2_support</a>()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using BMI2 intrinsics: YES\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="preprocessor">#ifdef SECP256K1_HAS_ASM</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Using assembly: YES\n&quot;</span>;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Using portable C++\n&quot;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="ttc" id="afield__asm_8hpp_html"><div class="ttname"><a href="field__asm_8hpp.html">field_asm.hpp</a></div></div>
<div class="ttc" id="anamespacesecp256k1_1_1fast_html_a2bd3922bd58f8a6d328d28d52003c3a1"><div class="ttname"><a href="namespacesecp256k1_1_1fast.html#a2bd3922bd58f8a6d328d28d52003c3a1">secp256k1::fast::has_bmi2_support</a></div><div class="ttdeci">bool has_bmi2_support()</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
üìä Performance</h1>
<p>Benchmarks below are from <code>bench_comprehensive_riscv</code> (Release builds). RISC-V results were collected on <b>Milk-V Mars</b> (RV64 + RVV).</p>
<h2><a class="anchor" id="autotoc_md38"></a>
x86_64 / Windows (Clang 21.1.0, Release)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">32 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">28 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">11 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Sub   </td><td class="markdownTableBodyRight">12 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inverse   </td><td class="markdownTableBodyRight">5 us    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyRight">644 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyRight">313 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Scalar Mul   </td><td class="markdownTableBodyRight">111 us    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generator Mul   </td><td class="markdownTableBodyRight">7 us    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Batch Inverse (n=100)   </td><td class="markdownTableBodyRight">145 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batch Inverse (n=1000)   </td><td class="markdownTableBodyRight">98 ns   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md39"></a>
x86_64 / Linux (i5, Clang 19.1.7, AVX2, Release)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">33 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">32 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">11 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Sub   </td><td class="markdownTableBodyRight">12 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inverse   </td><td class="markdownTableBodyRight">5 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyRight">521 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyRight">278 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Scalar Mul   </td><td class="markdownTableBodyRight">110 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generator Mul   </td><td class="markdownTableBodyRight">5 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Batch Inverse (n=100)   </td><td class="markdownTableBodyRight">140 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batch Inverse (n=1000)   </td><td class="markdownTableBodyRight">92 ns   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md40"></a>
RISC-V 64-bit / Linux (Milk-V Mars, RVV, Clang 21.1.8, Release)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">173 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">160 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">38 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Sub   </td><td class="markdownTableBodyRight">34 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inverse   </td><td class="markdownTableBodyRight">17 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyRight">3 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyRight">1 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Scalar Mul   </td><td class="markdownTableBodyRight">621 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generator Mul   </td><td class="markdownTableBodyRight">37 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Batch Inverse (n=100)   </td><td class="markdownTableBodyRight">695 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batch Inverse (n=1000)   </td><td class="markdownTableBodyRight">547 ns   </td></tr>
</table>
<p><em>See RISCV_OPTIMIZATIONS.md for optimization details.</em></p>
<h2><a class="anchor" id="autotoc_md41"></a>
ESP32-S3 / Embedded (Xtensa LX7 @ 240 MHz, ESP-IDF v5.5.1, -O3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">7,458 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">7,592 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">636 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyRight">844 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scalar √ó G (Generator Mul)   </td><td class="markdownTableBodyRight">2,483 Œºs   </td></tr>
</table>
<p><em>Portable C++ (no <code>__int128</code>, no assembly). All 35 library tests pass. See <a href="examples/esp32_test/">examples/esp32_test/</a> for details.</em></p>
<h2><a class="anchor" id="autotoc_md42"></a>
ESP32-PICO-D4 / Embedded (Xtensa LX6 Dual Core @ 240 MHz, ESP-IDF v5.5.1, -O3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">6,993 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">6,247 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">985 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyRight">609 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scalar √ó G (Generator Mul)   </td><td class="markdownTableBodyRight">6,203 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CT Scalar √ó G   </td><td class="markdownTableBodyRight">44,810 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CT Add (complete)   </td><td class="markdownTableBodyRight">249,672 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CT Dbl   </td><td class="markdownTableBodyRight">87,113 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CT/Fast ratio   </td><td class="markdownTableBodyRight">6.5√ó   </td></tr>
</table>
<p><em>Portable C++ (no <code>__int128</code>, no assembly). All 35 self-tests + 8 CT tests pass. See <a href="examples/esp32_test/">examples/esp32_test/</a> for details.</em></p>
<h2><a class="anchor" id="autotoc_md43"></a>
STM32F103ZET6 / Embedded (ARM Cortex-M3 @ 72 MHz, GCC 13.3.1, -O3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">15,331 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">12,083 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">4,139 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyRight">1,645 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scalar √ó G (Generator Mul)   </td><td class="markdownTableBodyRight">37,982 Œºs   </td></tr>
</table>
<p><em>ARM Cortex-M3 inline assembly (UMULL/ADDS/ADCS) for multiply/squaring/reduction. Portable C++ for field add/sub. All 35 library tests pass. See <a href="examples/stm32_test/">examples/stm32_test/</a> for details.</em></p>
<h2><a class="anchor" id="autotoc_md44"></a>
Android ARM64 (RK3588, Cortex-A55/A76 @ 2.4 GHz, NDK r27 Clang 18, -O3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">Time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">85 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">66 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">18 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Sub   </td><td class="markdownTableBodyRight">16 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inverse   </td><td class="markdownTableBodyRight">2,621 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar Mul   </td><td class="markdownTableBodyRight">105 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scalar Add   </td><td class="markdownTableBodyRight">12 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyRight">9,329 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyRight">8,711 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fast Scalar √ó G (Generator Mul)   </td><td class="markdownTableBodyRight">7.6 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fast Scalar √ó P (Non-Generator)   </td><td class="markdownTableBodyRight">77.6 Œºs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CT Scalar √ó G   </td><td class="markdownTableBodyRight">545 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CT ECDH   </td><td class="markdownTableBodyRight">545 Œºs   </td></tr>
</table>
<p><em>ARM64 inline assembly (MUL/UMULH) for field mul/sqr/add/sub/neg. ~5√ó faster than generic C++. All 12 Android tests pass. See <a href="android/">android/</a> for details.</em></p>
<h2><a class="anchor" id="autotoc_md45"></a>
Embedded Cross-Platform Comparison</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadRight">ESP32-S3 LX7 (240 MHz)   </th><th class="markdownTableHeadRight">ESP32 LX6 (240 MHz)   </th><th class="markdownTableHeadRight">STM32F103 (72 MHz)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyRight">7,458 ns   </td><td class="markdownTableBodyRight">6,993 ns   </td><td class="markdownTableBodyRight">15,331 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Square   </td><td class="markdownTableBodyRight">7,592 ns   </td><td class="markdownTableBodyRight">6,247 ns   </td><td class="markdownTableBodyRight">12,083 ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyRight">636 ns   </td><td class="markdownTableBodyRight">985 ns   </td><td class="markdownTableBodyRight">4,139 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyRight">844 Œºs   </td><td class="markdownTableBodyRight">609 Œºs   </td><td class="markdownTableBodyRight">1,645 Œºs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scalar √ó G   </td><td class="markdownTableBodyRight">2,483 Œºs   </td><td class="markdownTableBodyRight">6,203 Œºs   </td><td class="markdownTableBodyRight">37,982 Œºs   </td></tr>
</table>
<p><em>Clock-Normalized = (STM32 time √ó 72) / (ESP32 time √ó 240). Values &lt; 1.0 mean STM32 is faster per-clock.</em></p>
<h2><a class="anchor" id="autotoc_md46"></a>
CUDA (NVIDIA RTX 5060 Ti) ‚Äî Kernel-Only</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Time/Op   </th><th class="markdownTableHeadNone">Throughput    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">4,139 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">4,122 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyNone">12.1 ns   </td><td class="markdownTableBodyNone">82.65 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyNone">1.1 ns   </td><td class="markdownTableBodyNone">916 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyNone">0.7 ns   </td><td class="markdownTableBodyNone">1,352 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar Mul (P√ók)   </td><td class="markdownTableBodyNone">266.5 ns   </td><td class="markdownTableBodyNone">3.75 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generator Mul (G√ók)   </td><td class="markdownTableBodyNone">216.1 ns   </td><td class="markdownTableBodyNone">4.63 M/s   </td></tr>
</table>
<p><em>CUDA 12.0, sm_86;sm_89, batch=1M, RTX 5060 Ti (36 SMs, 2602 MHz)</em></p>
<h2><a class="anchor" id="autotoc_md47"></a>
OpenCL (NVIDIA RTX 5060 Ti) ‚Äî Kernel-Only</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Time/Op   </th><th class="markdownTableHeadNone">Throughput    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">4,137 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">4,124 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Sqr   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">5,985 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyNone">14.3 ns   </td><td class="markdownTableBodyNone">69.97 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyNone">1.6 ns   </td><td class="markdownTableBodyNone">630.6 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyNone">0.9 ns   </td><td class="markdownTableBodyNone">1,139 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kG (Generator Mul)   </td><td class="markdownTableBodyNone">295.1 ns   </td><td class="markdownTableBodyNone">3.39 M/s   </td></tr>
</table>
<p><em>OpenCL 3.0 CUDA, Driver 580.126.09, PTX inline asm, batch=256K‚Äì1M</em></p>
<h2><a class="anchor" id="autotoc_md48"></a>
CUDA vs OpenCL ‚Äî Kernel-Only Comparison (RTX 5060 Ti)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">CUDA   </th><th class="markdownTableHeadNone">OpenCL   </th><th class="markdownTableHeadNone">Faster    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">Tie    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">0.2 ns   </td><td class="markdownTableBodyNone">Tie    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyNone">12.1 ns   </td><td class="markdownTableBodyNone">14.3 ns   </td><td class="markdownTableBodyNone">CUDA 1.18√ó    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyNone">0.7 ns   </td><td class="markdownTableBodyNone">0.9 ns   </td><td class="markdownTableBodyNone"><b>CUDA 1.29√ó</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyNone">1.1 ns   </td><td class="markdownTableBodyNone">1.6 ns   </td><td class="markdownTableBodyNone"><b>CUDA 1.45√ó</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kG (Generator Mul)   </td><td class="markdownTableBodyNone">216.1 ns   </td><td class="markdownTableBodyNone">295.1 ns   </td><td class="markdownTableBodyNone"><b>CUDA 1.37√ó</b>   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> Both measurements are kernel-only (no buffer allocation/copy overhead). CUDA uses local-variable optimization for zero pointer-aliasing overhead. </p>
</blockquote>
<p><em>Benchmarks: 2026-02-14, Linux x86_64, NVIDIA Driver 580.126.09</em></p>
<h2><a class="anchor" id="autotoc_md49"></a>
Apple Metal (Apple M3 Pro) ‚Äî Kernel-Only</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Time/Op   </th><th class="markdownTableHeadNone">Throughput    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Mul   </td><td class="markdownTableBodyNone">1.9 ns   </td><td class="markdownTableBodyNone">527 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Add   </td><td class="markdownTableBodyNone">1.0 ns   </td><td class="markdownTableBodyNone">990 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Sub   </td><td class="markdownTableBodyNone">1.1 ns   </td><td class="markdownTableBodyNone">892 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field Sqr   </td><td class="markdownTableBodyNone">1.1 ns   </td><td class="markdownTableBodyNone">872 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Inv   </td><td class="markdownTableBodyNone">106.4 ns   </td><td class="markdownTableBodyNone">9.40 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Point Add   </td><td class="markdownTableBodyNone">10.1 ns   </td><td class="markdownTableBodyNone">98.6 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point Double   </td><td class="markdownTableBodyNone">5.1 ns   </td><td class="markdownTableBodyNone">196 M/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar Mul (P√ók)   </td><td class="markdownTableBodyNone">2.94 Œºs   </td><td class="markdownTableBodyNone">0.34 M/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generator Mul (G√ók)   </td><td class="markdownTableBodyNone">3.00 Œºs   </td><td class="markdownTableBodyNone">0.33 M/s   </td></tr>
</table>
<p><em>Metal 2.4, 8√ó32-bit Comba limbs, Apple M3 Pro (18 GPU cores, Unified Memory 18 GB)</em></p>
<h1><a class="anchor" id="autotoc_md50"></a>
üèóÔ∏è Architecture</h1>
<div class="fragment"><div class="line">secp256k1-fast/</div>
<div class="line">‚îú‚îÄ‚îÄ cpu/                 # CPU-optimized implementation</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ include/         # Public headers</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ src/            # Implementation</div>
<div class="line">‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ field.cpp           # Field arithmetic</div>
<div class="line">‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scalar.cpp          # Scalar arithmetic</div>
<div class="line">‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ point.cpp           # Point operations</div>
<div class="line">‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ field_asm_x64.asm   # x64 assembly</div>
<div class="line">‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ field_asm_x64_gas.S # x64 GAS syntax</div>
<div class="line">‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ field_asm_riscv64.S # RISC-V assembly</div>
<div class="line">‚îÇ   ‚îî‚îÄ‚îÄ tests/          # Unit tests</div>
<div class="line">‚îú‚îÄ‚îÄ cuda/               # CUDA GPU acceleration</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ include/        # CUDA headers</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ src/           # CUDA kernels</div>
<div class="line">‚îÇ   ‚îî‚îÄ‚îÄ tests/         # CUDA tests</div>
<div class="line">‚îú‚îÄ‚îÄ opencl/            # OpenCL GPU acceleration</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ kernels/       # OpenCL kernel sources (.cl)</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ include/       # OpenCL headers</div>
<div class="line">‚îÇ   ‚îú‚îÄ‚îÄ src/           # Host-side OpenCL code</div>
<div class="line">‚îÇ   ‚îî‚îÄ‚îÄ tests/         # OpenCL tests</div>
<div class="line">‚îî‚îÄ‚îÄ examples/</div>
<div class="line">    ‚îú‚îÄ‚îÄ esp32_test/    # ESP32-S3 Xtensa LX7 port</div>
<div class="line">    ‚îî‚îÄ‚îÄ stm32_test/    # STM32F103ZET6 ARM Cortex-M3 port</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
üî¨ Research Statement</h1>
<p>This library explores the performance ceiling of <a class="el" href="namespacesecp256k1.html">secp256k1</a> across CPU architectures (x64, ARM64, RISC-V, Cortex-M, Xtensa) and GPUs (CUDA, OpenCL, Metal, ROCm). Zero external dependencies.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
üìö Variant Overview</h1>
<p>Internal 32-bit arithmetic variants (historical optimization stages):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variant   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>secp256k1_32_fast</code>   </td><td class="markdownTableBodyNone">Speed-first, variable-time    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>secp256k1_32_hybrid_smart</code>   </td><td class="markdownTableBodyNone">Mixed strategy experiments    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>secp256k1_32_hybrid_final</code>   </td><td class="markdownTableBodyNone">Stabilized hybrid arithmetic    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>secp256k1_32_really_final</code>   </td><td class="markdownTableBodyNone">Most mature 32-bit variant   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md53"></a>
üö´ Scope</h1>
<p>This is an ECC arithmetic library. It provides field/scalar/point operations, signature schemes (ECDSA, Schnorr, MuSig2, FROST, Adaptor), Pedersen commitments, Taproot, HD derivation (BIP-32/44), and 27-coin address generation. It does not include key storage, wallet software, network protocols, or attack tools.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
‚ö†Ô∏è API Stability</h1>
<p>The public API is <b>not yet stable</b>. Breaking changes may occur in any minor release before <b>v4.0</b>.</p>
<p>Core layers (field, scalar, point, ECDSA, Schnorr) have mature interfaces unlikely to change. Experimental layers (MuSig2, FROST, Adaptor, Pedersen, Taproot, HD, Coins) may see breaking changes in any release.</p>
<p>Pin your dependency version and review changelogs before upgrading.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
üìö Documentation</h1>
<ul>
<li>Documentation Index</li>
<li>API Reference</li>
<li>Build Guide</li>
<li>Benchmarks</li>
<li>Threat Model</li>
<li>Contributing</li>
<li>Security Policy</li>
<li>Changelog</li>
</ul>
<h1><a class="anchor" id="autotoc_md56"></a>
üß™ Testing</h1>
<h2><a class="anchor" id="autotoc_md57"></a>
Built-in Selftest</h2>
<p>The library includes a comprehensive self-test (<code>Selftest()</code>) that runs <b>deterministic KAT vectors</b> covering all arithmetic operations. Every test/bench executable runs this selftest on startup.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Three Modes</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Time   </th><th class="markdownTableHeadNone">When   </th><th class="markdownTableHeadNone">What    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>smoke</b>   </td><td class="markdownTableBodyNone">~1-2s   </td><td class="markdownTableBodyNone">App startup, embedded   </td><td class="markdownTableBodyNone">Core KAT (10 scalar mul, field/scalar identities, point ops, batch inverse, boundary vectors)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>ci</b>   </td><td class="markdownTableBodyNone">~30-90s   </td><td class="markdownTableBodyNone">Every push (CI)   </td><td class="markdownTableBodyNone">Smoke + cross-checks, bilinearity, NAF/wNAF, batch sweeps, fast-vs-generic, algebraic stress    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>stress</b>   </td><td class="markdownTableBodyNone">~10-60min   </td><td class="markdownTableBodyNone">Nightly / manual   </td><td class="markdownTableBodyNone">CI + 1000 random scalar muls, 500 field triples, 100 bilinearity pairs, batch inverse up to 8192   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="selftest_8hpp.html">secp256k1/selftest.hpp</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacesecp256k1_1_1fast.html">secp256k1::fast</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Legacy (runs ci mode):</span></div>
<div class="line">Selftest(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicit mode + seed:</span></div>
<div class="line">Selftest(<span class="keyword">true</span>, SelftestMode::smoke);              <span class="comment">// Fast startup check</span></div>
<div class="line">Selftest(<span class="keyword">true</span>, SelftestMode::ci);                  <span class="comment">// Full CI suite</span></div>
<div class="line">Selftest(<span class="keyword">true</span>, SelftestMode::stress, 0xDEADBEEF); <span class="comment">// Nightly with custom seed</span></div>
<div class="ttc" id="aselftest_8hpp_html"><div class="ttname"><a href="selftest_8hpp.html">selftest.hpp</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md59"></a>
Repro Bundle</h2>
<p>On verbose output, selftest prints everything needed to reproduce a failure:</p>
<div class="fragment"><div class="line">Mode:     ci</div>
<div class="line">Seed:     0x53454350324b3147</div>
<div class="line">Compiler: Clang 17.0.6</div>
<div class="line">Platform: Linux x64</div>
<div class="line">Build:    Release</div>
<div class="line">ASM:      enabled</div>
<div class="line">Repro:    Selftest(true, SelftestMode::ci, 0x53454350324b3147)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
Sanitizer Builds</h2>
<div class="fragment"><div class="line"># ASan + UBSan (catches UB, out-of-bounds, use-after-free)</div>
<div class="line">cmake --preset cpu-asan</div>
<div class="line">cmake --build build/cpu-asan -j</div>
<div class="line">ctest --test-dir build/cpu-asan --output-on-failure</div>
<div class="line"> </div>
<div class="line"># TSan (catches data races in multi-threaded code)</div>
<div class="line">cmake --preset cpu-tsan</div>
<div class="line">cmake --build build/cpu-tsan -j</div>
<div class="line">ctest --test-dir build/cpu-tsan --output-on-failure</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Running Tests</h2>
<div class="fragment"><div class="line"># Build and run all tests (ci mode)</div>
<div class="line">cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DSECP256K1_BUILD_TESTS=ON</div>
<div class="line">cmake --build build -j</div>
<div class="line">ctest --test-dir build --output-on-failure</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Platform Coverage Dashboard</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Backend   </th><th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadNone">Selftest CI   </th><th class="markdownTableHeadNone">Stress   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux x64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">GCC 13   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Debug + Release    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Linux x64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">Clang 17   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Debug + Release    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux x64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">Clang 17 (ASan+UBSan)   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Sanitizer build    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Linux x64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">Clang 17 (TSan)   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Thread sanitizer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows x64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">MSVC 2022   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Release    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">macOS ARM64   </td><td class="markdownTableBodyNone">CPU + Metal   </td><td class="markdownTableBodyNone">AppleClang   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Apple Silicon    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">macOS ARM64   </td><td class="markdownTableBodyNone">Metal GPU   </td><td class="markdownTableBodyNone">AppleClang   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">GPU shader tests    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">iOS ARM64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">Xcode   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Device + Simulator    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Android ARM64   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">NDK r27c   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">arm64-v8a    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WebAssembly   </td><td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyNone">Emscripten   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Build + WASM benchmark    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ROCm/HIP   </td><td class="markdownTableBodyNone">CPU + GPU   </td><td class="markdownTableBodyNone">ROCm 6.3   </td><td class="markdownTableBodyNone">‚úÖ CI   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Compile + CPU test   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;Community-tested platforms: if you run selftest on a new platform, submit the log via PR and we'll add a row. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md63"></a>
Fuzz Testing</h2>
<p>libFuzzer harnesses cover core arithmetic (<code>cpu/fuzz/</code>):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Target   </th><th class="markdownTableHeadNone">What it tests    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fuzz_field</code>   </td><td class="markdownTableBodyNone">add/sub round-trip, mul identity, square equivalence, inverse    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fuzz_scalar</code>   </td><td class="markdownTableBodyNone">add/sub, mul identity, distributive law    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fuzz_point</code>   </td><td class="markdownTableBodyNone">on-curve check, negate, compress round-trip, dbl vs add   </td></tr>
</table>
<div class="fragment"><div class="line">clang++ -fsanitize=fuzzer,address -O2 -std=c++20 \</div>
<div class="line">  -I cpu/include cpu/fuzz/fuzz_field.cpp cpu/src/field.cpp cpu/src/field_asm.cpp \</div>
<div class="line">  -o fuzz_field &amp;&amp; ./fuzz_field -max_len=64 -runs=10000000</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md64"></a>
ü§ù Contributing</h1>
<p>Contributions are welcome! Please read CONTRIBUTING.md for guidelines.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Development Setup</h2>
<div class="fragment"><div class="line">git clone https://github.com/shrec/UltrafastSecp256k1.git</div>
<div class="line">cd UltrafastSecp256k1</div>
<div class="line">cmake -S . -B build-dev -G Ninja -DCMAKE_BUILD_TYPE=Debug</div>
<div class="line">cmake --build build-dev -j</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md66"></a>
üìÑ License</h1>
<p>This project is licensed under the <b>GNU Affero General Public License v3.0 (AGPL-3.0)</b>.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Open Source License</h2>
<p>The library is free to use under AGPL-3.0 for open source projects. This means:</p><ul>
<li>‚úÖ You can use, modify, and distribute the code</li>
<li>‚úÖ You must disclose your source code</li>
<li>‚úÖ You must license your project under AGPL-3.0 or compatible license</li>
<li>‚úÖ You must provide network access to your source code if you run it as a service</li>
</ul>
<p>See [LICENSE](LICENSE) for full details.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Commercial License</h2>
<p><b>For commercial/proprietary use without AGPL-3.0 obligations:</b></p>
<p>If you want to use this library in a proprietary/closed-source product or service without disclosing your source code, please contact us for a commercial license.</p>
<p>üìß <b>Contact for commercial licensing:</b></p><ul>
<li>Email: <a href="#" onclick="location.href='mai'+'lto:'+'pay'+'ys'+'oon'+'@g'+'mai'+'l.'+'com'; return false;">payysoon@gmail.com</a></li>
<li>GitHub: <a href="https://github.com/shrec/UltrafastSecp256k1">https://github.com/shrec/UltrafastSecp256k1</a></li>
</ul>
<p>We offer flexible licensing options for commercial applications.</p>
<h1><a class="anchor" id="autotoc_md69"></a>
üôè Acknowledgments</h1>
<ul>
<li>Based on optimized <a class="el" href="namespacesecp256k1.html">secp256k1</a> implementations</li>
<li>Inspired by Bitcoin Core's libsecp256k1</li>
<li>RISC-V assembly contributions</li>
<li>CUDA kernel optimizations</li>
</ul>
<h1><a class="anchor" id="autotoc_md70"></a>
üìß Contact &amp; Community</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Channel   </th><th class="markdownTableHeadNone">Link    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Issues   </td><td class="markdownTableBodyNone"><a href="https://github.com/shrec/UltrafastSecp256k1/issues">GitHub Issues</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Discussions   </td><td class="markdownTableBodyNone"><a href="https://github.com/shrec/UltrafastSecp256k1/discussions">GitHub Discussions</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Wiki   </td><td class="markdownTableBodyNone"><a href="https://github.com/shrec/UltrafastSecp256k1/wiki">Documentation Wiki</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Benchmarks   </td><td class="markdownTableBodyNone"><a href="https://shrec.github.io/UltrafastSecp256k1/dev/bench/">Live Dashboard</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">API Docs   </td><td class="markdownTableBodyNone"><a href="https://shrec.github.io/UltrafastSecp256k1/docs/">Doxygen</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Security   </td><td class="markdownTableBodyNone"><a href="https://github.com/shrec/UltrafastSecp256k1/security/advisories/new">Report Vulnerability</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Commercial   </td><td class="markdownTableBodyNone"><a href="#" onclick="location.href='mai'+'lto:'+'pay'+'ys'+'oon'+'@g'+'mai'+'l.'+'com'; return false;">payysoon@gmail.com</a>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md71"></a>
‚òï Support the Project</h1>
<p>If you find this library useful, consider supporting development!</p>
<p><a href="https://github.com/sponsors/shrec"><img src="https://img.shields.io/badge/Sponsor-GitHub%20Sponsors-ea4aaa.svg?logo=github" alt="Sponsor" style="pointer-events: none;" class="inline"/></a> <a href="https://paypal.me/IChkheidze"><img src="https://img.shields.io/badge/PayPal-Donate-blue.svg?logo=paypal" alt="PayPal" style="pointer-events: none;" class="inline"/></a></p>
<hr  />
<p><b>UltrafastSecp256k1</b> - Ultra high-performance elliptic curve cryptography for modern hardware. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
