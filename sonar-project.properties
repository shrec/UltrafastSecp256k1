# SonarCloud project configuration
# https://sonarcloud.io/project/configuration

sonar.organization=shrec
sonar.projectKey=shrec_UltrafastSecp256k1
sonar.projectName=UltrafastSecp256k1

# Source layout
sonar.sources=cpu/src,cpu/include,include,cuda/src,cuda/include
sonar.tests=cpu/tests
sonar.sourceEncoding=UTF-8

# C/C++ settings
sonar.cfamily.threads=4

# Exclusions (generated, third-party, build artifacts)
sonar.exclusions=\
  build/**,\
  build-*/**,\
  cmake-build-*/**,\
  bindings/**,\
  _research_repos/**,\
  DBFiles/**,\
  GenTools/**

# Coverage / test exclusions
sonar.coverage.exclusions=\
  cpu/tests/**,\
  cpu/bench/**,\
  cuda/bench/**,\
  audit/**,\
  include/ufsecp/**,\
  **/benchmark*.hpp,\
  **/benchmark*.cpp

# Duplicate detection
# Crypto library has intentional structural duplication between fast (variable-
# time) and constant-time (CT) variants (e.g. schnorr.cpp vs ct_sign.cpp).
# Raise threshold to avoid false positives on these architectural mirrors.
sonar.cpd.minimumTokens=120

# Exclude constant-time (CT) variant files from copy-paste detection.
# CT code intentionally mirrors the variable-time implementation line-for-line
# to guarantee identical control flow (branchless, no timing side-channels).
# This structural duplication is an architectural requirement, not copy-paste.
sonar.cpd.exclusions=**/ct_*.cpp

# ---------------------------------------------------------------------------
# False-positive suppression for cryptographic code patterns
# ---------------------------------------------------------------------------
# cpp:S876 (MISRA unary minus on unsigned) -- intentional in CT masking:
#   -static_cast<uint64_t>(cond) produces 0x0 or 0xFFFFFFFFFFFFFFFF.
#   This is the fundamental branchless selection idiom in constant-time code.
#   Well-defined behavior: unsigned negation wraps per C++ standard [conv.integral].
sonar.issue.ignore.multicriteria=e1,e2
sonar.issue.ignore.multicriteria.e1.ruleKey=cpp:S876
sonar.issue.ignore.multicriteria.e1.resourceKey=**/*

# cpp:S3519 (buffer overflow via symbolic execution) -- false positive in SHA-256
#   finalize() padding. buf_len_ is invariantly [0,63] after update() processes
#   all full 64-byte blocks, so buf_[pos] with pos in [0,63] is always valid.
#   SonarCloud's cross-function symbolic execution (schnorr -> tagged_hash ->
#   SHA256::finalize) cannot track this class invariant through the call chain.
sonar.issue.ignore.multicriteria.e2.ruleKey=cpp:S3519
sonar.issue.ignore.multicriteria.e2.resourceKey=**/sha256.hpp
